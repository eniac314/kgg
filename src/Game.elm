module Game exposing (..)

import ApiCalls
import Dict
import Helpers exposing (shuffleSeed)
import Lamdera exposing (broadcast, sendToFrontend)
import List.Extra
import Random
import Set
import Time
import Types exposing (..)


updateConfig :
    BackendModel
    -> GameId
    -> { kanjiSet : KanjiSet, roundLength : Int, startingCountdown : Int }
    -> ( BackendModel, Cmd BackendMsg )
updateConfig model gameId config =
    case Dict.get gameId model.kggames of
        Just game ->
            case game.gameState of
                Lobby _ ->
                    let
                        newGame =
                            { game | gameState = Lobby config }
                    in
                    ( { model | kggames = Dict.insert gameId newGame model.kggames }
                    , broadcastGame newGame
                    )

                _ ->
                    ( model, Cmd.none )

        _ ->
            ( model, Cmd.none )


createGame : BackendModel -> Time.Posix -> Player -> { kanjiSet : KanjiSet, roundLength : Int, startingCountdown : Int } -> ( BackendModel, Cmd BackendMsg )
createGame model now host config =
    let
        nextId =
            Dict.keys model.kggames
                |> List.foldr max -1
                |> (\n -> n + 1)

        newGame =
            { gameId = nextId
            , host = host
            , players = [ host ]
            , gameState = Lobby config
            , lastUpdated = Time.posixToMillis now
            , buffering = False
            , initialBuffer = False

            --, roundLength : Int
            }
    in
    ( { model | kggames = Dict.insert nextId newGame model.kggames }, broadcastGame newGame )


joinGame : BackendModel -> Player -> GameId -> ( BackendModel, Cmd BackendMsg )
joinGame model player gameId =
    case Dict.get gameId model.kggames of
        Just game ->
            let
                newGame =
                    { game
                        | players =
                            if not <| List.member player game.players then
                                player :: game.players

                            else
                                game.players
                    }
            in
            ( { model | kggames = Dict.insert gameId newGame model.kggames }, broadcastGame newGame )

        _ ->
            ( model, Cmd.none )


leaveGame : BackendModel -> Player -> GameId -> ( BackendModel, Cmd BackendMsg )
leaveGame model player gameId =
    case Dict.get gameId model.kggames of
        Just game ->
            let
                newGame =
                    { game
                        | players =
                            if List.member player game.players then
                                List.Extra.remove player game.players

                            else
                                game.players
                    }
            in
            ( { model | kggames = Dict.insert gameId newGame model.kggames }, broadcastGame newGame )

        _ ->
            ( model, Cmd.none )


launchPlay : BackendModel -> GameId -> ( BackendModel, Cmd BackendMsg )
launchPlay model gameId =
    case Dict.get gameId model.kggames of
        Just game ->
            case game.gameState of
                Lobby config ->
                    let
                        ( newSeed, kanjiForThisGame, bufferedKanji ) =
                            (\( s, r ) -> ( s, List.drop 5 r, List.take 5 r )) <|
                                case config.kanjiSet of
                                    JlptSet levels ->
                                        List.filterMap (\n -> Dict.get n jlpt) levels
                                            |> List.concatMap String.toList
                                            |> shuffleSeed model.seed

                                    CustomKanjiSet kanjiList ->
                                        ( model.seed, kanjiList )

                        currentKanji =
                            List.head bufferedKanji |> Maybe.withDefault '‚ùå'

                        allTheWords =
                            Dict.empty

                        newGameState =
                            InPlay <|
                                { score = 0
                                , currentKanji = currentKanji
                                , remainingKanji = kanjiForThisGame
                                , bufferedKanji = List.tail bufferedKanji |> Maybe.withDefault []
                                , kanjiSeen = []
                                , words = Dict.empty
                                , allowedWords = allTheWords
                                , requestedSkip = []
                                , timeTillRoundEnd = config.roundLength
                                , timeTillGameOver = config.startingCountdown
                                , roundLength = config.roundLength
                                , startingCountdown = config.startingCountdown
                                }

                        newGame =
                            { game | gameState = newGameState, buffering = True, initialBuffer = True }
                    in
                    ( { model | kggames = Dict.insert gameId newGame model.kggames, seed = newSeed }
                    , Cmd.batch [ ApiCalls.getAllTheWords gameId bufferedKanji ]
                    )

                _ ->
                    ( model, Cmd.none )

        _ ->
            ( model, Cmd.none )


runGames : BackendModel -> Time.Posix -> ( BackendModel, Cmd BackendMsg )
runGames model now =
    List.foldr
        (\g ( currentModel, cmds ) ->
            if gameRunning g then
                let
                    ( newModel, newCmd ) =
                        runGame currentModel now g.gameId
                in
                ( { currentModel | kggames = Dict.union newModel.kggames currentModel.kggames }
                , newCmd :: cmds
                )

            else
                ( currentModel, cmds )
        )
        ( model, [] )
        (Dict.values model.kggames)
        |> Tuple.mapSecond Cmd.batch


runGame : BackendModel -> Time.Posix -> GameId -> ( BackendModel, Cmd BackendMsg )
runGame model now gameId =
    case Dict.get gameId model.kggames of
        Just game ->
            let
                timeStampedModel =
                    addTimeStampModel model gameId now
            in
            case game.gameState of
                Lobby config ->
                    launchPlay timeStampedModel gameId

                InPlay _ ->
                    toNextRound timeStampedModel gameId

                Victory _ ->
                    ( timeStampedModel, Cmd.none )

                GameOver _ ->
                    ( timeStampedModel, Cmd.none )

        _ ->
            ( model, Cmd.none )


requestNextKanji : BackendModel -> GameId -> Player -> ( BackendModel, Cmd BackendMsg )
requestNextKanji model gameId player =
    case Dict.get gameId model.kggames of
        Just game ->
            case game.gameState of
                InPlay substate ->
                    let
                        newGameState =
                            InPlay
                                { substate
                                    | requestedSkip =
                                        if not <| List.member player substate.requestedSkip then
                                            player :: substate.requestedSkip

                                        else
                                            substate.requestedSkip
                                }

                        newGame =
                            { game | gameState = newGameState }
                    in
                    ( { model | kggames = Dict.insert gameId newGame model.kggames }, broadcastGame newGame )

                _ ->
                    ( model, Cmd.none )

        _ ->
            ( model, Cmd.none )


allPlayerRequestedNextKanji game =
    case game.gameState of
        InPlay substate ->
            Set.fromList (List.map .id game.players) == Set.fromList (List.map .id substate.requestedSkip)

        _ ->
            False


addWord : BackendModel -> GameId -> Player -> String -> ( BackendModel, Cmd BackendMsg )
addWord model gameId player word =
    case Dict.get gameId model.kggames of
        Just game ->
            case game.gameState of
                InPlay substate ->
                    let
                        currentWords =
                            Dict.get player.id substate.words |> Maybe.withDefault []

                        numberOfPlayers =
                            List.length game.players

                        timeBonus =
                            floor (10 / toFloat numberOfPlayers)

                        roundTimeBonus =
                            floor (5 / toFloat numberOfPlayers)

                        updateGame ns =
                            let
                                newGame =
                                    { game | gameState = InPlay ns }
                            in
                            ( { model | kggames = Dict.insert gameId newGame model.kggames }
                            , Cmd.batch
                                [ broadcastGame newGame
                                , if not <| canAddWord word game then
                                    sendToFrontend player.id (WrongWordTF word)

                                  else
                                    Cmd.none
                                ]
                            )

                        newSubstate =
                            if canAddWord word game then
                                { substate
                                    | score = substate.score + 10
                                    , words = Dict.insert player.id (word :: currentWords) substate.words
                                    , timeTillRoundEnd = substate.timeTillRoundEnd + roundTimeBonus
                                    , timeTillGameOver = substate.timeTillGameOver + timeBonus
                                }

                            else
                                { substate
                                    | timeTillRoundEnd = substate.timeTillRoundEnd - roundTimeBonus
                                    , timeTillGameOver = substate.timeTillGameOver - timeBonus
                                }
                    in
                    updateGame newSubstate

                _ ->
                    ( model, Cmd.none )

        Nothing ->
            ( model, Cmd.none )


canAddWord : String -> KanjiGuessingGame -> Bool
canAddWord word game =
    case game.gameState of
        InPlay substate ->
            case Dict.get substate.currentKanji substate.allowedWords of
                Just relevantAllowedWords ->
                    (not <| List.member word (List.concat <| Dict.values substate.words))
                        && List.member word relevantAllowedWords

                _ ->
                    False

        _ ->
            False


toNextRound : BackendModel -> GameId -> ( BackendModel, Cmd BackendMsg )
toNextRound model gameId =
    case Dict.get gameId model.kggames of
        Just game ->
            case game.gameState of
                InPlay substate ->
                    if game.initialBuffer then
                        ( model, Cmd.none )

                    else
                        let
                            noMoreTime =
                                substate.timeTillGameOver <= 1

                            roundOver =
                                substate.timeTillRoundEnd <= 1

                            newGameState =
                                { substate
                                    | timeTillRoundEnd = max 0 <| substate.timeTillRoundEnd - 1
                                    , timeTillGameOver = max 0 <| substate.timeTillGameOver - 1
                                }

                            updateGame gs =
                                let
                                    newGame =
                                        { game | gameState = InPlay gs }
                                in
                                { model | kggames = Dict.insert gameId newGame model.kggames }
                        in
                        if noMoreTime then
                            let
                                newGame =
                                    { game | gameState = GameOver { score = substate.score } }
                            in
                            ( { model | kggames = Dict.insert gameId newGame model.kggames }, broadcastGame newGame )

                        else if allPlayerRequestedNextKanji game && (not <| game.buffering) then
                            loadNextKanji (updateGame { newGameState | requestedSkip = [] }) gameId

                        else if roundOver then
                            loadNextKanji (updateGame newGameState) gameId

                        else
                            ( updateGame newGameState, broadcastGameTimes { game | gameState = InPlay newGameState } )

                _ ->
                    ( model, Cmd.none )

        _ ->
            ( model, Cmd.none )


loadNextKanji : BackendModel -> GameId -> ( BackendModel, Cmd BackendMsg )
loadNextKanji model gameId =
    case Dict.get gameId model.kggames of
        Just game ->
            case game.gameState of
                InPlay substate ->
                    let
                        mbNextKanjiToBuffer =
                            List.head substate.remainingKanji

                        updateGame ngs buffering cmd =
                            let
                                newGame =
                                    { game | gameState = ngs, buffering = buffering }
                            in
                            ( { model | kggames = Dict.insert gameId newGame model.kggames }
                            , Cmd.batch [ broadcastGame newGame, cmd ]
                            )
                    in
                    case substate.bufferedKanji of
                        [] ->
                            updateGame (Victory { score = substate.score }) False Cmd.none

                        nextKanji :: tail ->
                            updateGame
                                (InPlay
                                    { substate
                                        | currentKanji = nextKanji
                                        , kanjiSeen = substate.currentKanji :: substate.kanjiSeen
                                        , timeTillRoundEnd = substate.roundLength
                                        , remainingKanji = List.tail substate.remainingKanji |> Maybe.withDefault []
                                        , bufferedKanji =
                                            Maybe.map (\nkb -> tail ++ [ nkb ]) mbNextKanjiToBuffer
                                                |> Maybe.withDefault substate.bufferedKanji
                                    }
                                )
                                True
                                (Maybe.map (\nkb -> ApiCalls.getWords gameId nkb) mbNextKanjiToBuffer
                                    |> Maybe.withDefault Cmd.none
                                )

                _ ->
                    ( model, Cmd.none )

        Nothing ->
            ( model, Cmd.none )


gameRunning : KanjiGuessingGame -> Bool
gameRunning game =
    case game.gameState of
        InPlay _ ->
            True

        _ ->
            False


gamesRunning : BackendModel -> Bool
gamesRunning { kggames } =
    List.any
        (\g ->
            case g.gameState of
                InPlay _ ->
                    True

                _ ->
                    False
        )
        (Dict.values kggames)


addTimeStamp : KanjiGuessingGame -> Time.Posix -> KanjiGuessingGame
addTimeStamp game now =
    { game | lastUpdated = Time.posixToMillis now }


addTimeStampModel : BackendModel -> GameId -> Time.Posix -> BackendModel
addTimeStampModel model gameId now =
    case Dict.get gameId model.kggames of
        Just game ->
            { model | kggames = Dict.insert gameId { game | lastUpdated = Time.posixToMillis now } model.kggames }

        _ ->
            model


broadcastGame : KanjiGuessingGame -> Cmd BackendMsg
broadcastGame game =
    let
        gameStateLight =
            case game.gameState of
                InPlay substate ->
                    InPlay { substate | allowedWords = Dict.empty, remainingKanji = [] }

                _ ->
                    game.gameState
    in
    broadcast <| GameBroadcastTF { game | gameState = gameStateLight }


broadcastGameTimes : KanjiGuessingGame -> Cmd BackendMsg
broadcastGameTimes game =
    case game.gameState of
        InPlay substate ->
            broadcast <|
                GameTimesBroadcastTF
                    { gameId = game.gameId
                    , lastUpdated = game.lastUpdated
                    , timeTillGameOver = substate.timeTillGameOver
                    , timeTillRoundEnd = substate.timeTillRoundEnd
                    , buffering = game.buffering
                    }

        _ ->
            Cmd.none



-------------------------------------------------------------------------------


randomJLPTKanjiList : Random.Seed -> Int -> ( Random.Seed, List Char )
randomJLPTKanjiList seed level =
    case Dict.get level jlpt of
        Just kanjiStr ->
            shuffleSeed seed (String.toList kanjiStr)

        _ ->
            ( seed, [] )


jlpt =
    Dict.fromList
        [ ( 5, "Êó•‰∏ÄÂõΩ‰∫∫Âπ¥Â§ßÂçÅ‰∫åÊú¨‰∏≠Èï∑Âá∫‰∏âÊôÇË°åË¶ãÊúàÂàÜÂæåÂâçÁîü‰∫îÈñì‰∏äÊù±Âõõ‰ªäÈáë‰πùÂÖ•Â≠¶È´òÂÜÜÂ≠êÂ§ñÂÖ´ÂÖ≠‰∏ãÊù•Ê∞óÂ∞è‰∏ÉÂ±±Ë©±Â•≥ÂåóÂçàÁôæÊõ∏ÂÖàÂêçÂ∑ùÂçÉÊ∞¥ÂçäÁî∑Ë•øÈõªÊ†°Ë™ûÂúüÊú®ËÅûÈ£üËªä‰ΩïÂçó‰∏áÊØéÁôΩÂ§©ÊØçÁÅ´Âè≥Ë™≠ÂèãÂ∑¶‰ºëÁà∂Èõ®Â∫óÊïôÂ£≤Áü•Ëµ∑Ë®Ä" )
        , ( 4, "‰ºöÂêå‰∫ãËá™Á§æÁô∫ËÄÖÂú∞Ê•≠ÊñπÊñ∞Â†¥Âì°Á´ãÈñãÊâãÂäõÂïè‰ª£ÊòéÂãï‰∫¨ÁõÆÈÄöÁêÜ‰ΩìÁî∞‰∏ªÈ°åÊÑè‰∏ç‰ΩúÁî®Â∫¶Âº∑ÂÖ¨ÊåÅÈáé‰ª•ÊÄùÂÆ∂‰∏ñÂ§öÊ≠£ÂÆâÈô¢ÂøÉÁïåÊñáÂÖÉÈáçËøëËÄÉÁîªÊµ∑ÈÅìÈõÜÂà•Áâ©‰ΩøÂìÅË®àÊ≠ªÁâπÁßÅÂßãÊúùÈÅãÁµÇÂè∞Â∫É‰ΩèÁÑ°ÁúüÊúâÂè£Â∞ëÁî∫ÊñôÂ∑•Âª∫Á©∫ÊÄ•Ê≠¢ÈÄÅÂàáËª¢Á†îË∂≥Á©∂Ê•ΩÁùÄÁóÖË≥™ÂæÖË©¶ÊóèÈäÄÊó©Êò†Ë¶™È®ìËã±Âåª‰ªïÂéªÂë≥ÂÜôÂ≠óÁ≠îÂ§úÈü≥Ê≥®Â∏∞Âè§Ê≠åË≤∑ÊÇ™Âõ≥ÈÄ±ÂÆ§Ê≠©È¢®Á¥ôÈªíËä±Êò•Ëµ§ÈùíÈ§®Â±ãËâ≤Ëµ∞ÁßãÂ§èÁøíÈßÖÊ¥ãÊóÖÊúçÂ§ïÂÄüÊõúÈ£≤ËÇâË≤∏Â†ÇÈ≥•È£ØÂãâÂÜ¨ÊòºËå∂ÂºüÁâõÈ≠öÂÖÑÁä¨Â¶πÂßâÊº¢" )
        , ( 3, "ÊîøË≠∞Ê∞ëÈÄ£ÂØæÈÉ®ÂêàÂ∏ÇÂÜÖÁõ∏ÂÆöÂõûÈÅ∏Á±≥ÂÆüÈñ¢Ê±∫ÂÖ®Ë°®Êà¶ÁµåÊúÄÁèæË™øÂåñÂΩìÁ¥ÑÈ¶ñÊ≥ïÊÄßÁöÑË¶ÅÂà∂Ê≤ªÂãôÊàêÊúüÂèñÈÉΩÂíåÊ©üÂπ≥Âä†ÂèóÁ∂öÈÄ≤Êï∞Ë®òÂàùÊåáÊ®©ÊîØÁî£ÁÇπÂ†±Ê∏àÊ¥ªÂéüÂÖ±ÂæóËß£‰∫§Ë≥á‰∫àÂêëÈöõÂãùÈù¢ÂëäÂèçÂà§Ë™çÂèÇÂà©ÁµÑ‰ø°Âú®‰ª∂ÂÅ¥‰ªªÂºïÊ±ÇÊâÄÊ¨°Êò®Ë´ñÂÆòÂ¢ó‰øÇÊÑüÊÉÖÊäïÁ§∫Â§âÊâìÁõ¥‰∏°ÂºèÁ¢∫ÊûúÂÆπÂøÖÊºîÊ≠≥‰∫âË´áËÉΩ‰ΩçÁΩÆÊµÅÊ†ºÁñëÈÅéÂ±ÄÊîæÂ∏∏Áä∂ÁêÉËÅ∑‰∏é‰æõÂΩπÊßãÂâ≤Ë∫´Ë≤ª‰ªòÁî±Ë™¨Èõ£ÂÑ™Â§´ÂèéÊñ≠Áü≥ÈÅïÊ∂àÁ•ûÁï™Ë¶èË°ìÂÇôÂÆÖÂÆ≥ÈÖçË≠¶ËÇ≤Â∏≠Ë®™‰πóÊÆãÊÉ≥Â£∞Âä©Âä¥‰æãÁÑ∂ÈôêËøΩÂïÜËëâ‰ºùÂÉçÂΩ¢ÊôØËêΩÂ•ΩÈÄÄÈ†≠Ë≤†Ê∏°Â§±Â∑ÆÊú´ÂÆàËã•Á®ÆÁæéÂëΩÁ¶èÊúõÈùûË¶≥ÂØüÊÆµÊ®™Ê∑±Áî≥ÊßòË≤°Ê∏ØË≠òÂëºÈÅîËâØÈò™ÂÄôÁ®ãÊ∫ÄÊïóÂÄ§Á™ÅÂÖâË∑ØÁßëÁ©ç‰ªñÂá¶Â§™ÂÆ¢Âê¶Â∏´ÁôªÊòìÈÄüÂ≠òÈ£õÊÆ∫Âè∑ÂçòÂ∫ßÁ†¥Èô§ÂÆåÈôçË≤¨ÊçïÂç±Áµ¶Ëã¶ËøéÂúíÂÖ∑ËæûÂõ†È¶¨ÊÑõÂØåÂΩºÊú™Ëàû‰∫°ÂÜ∑ÈÅ©Â©¶ÂØÑËæºÈ°îÈ°û‰ΩôÁéãËøîÂ¶ªËÉåÁÜ±ÂÆøËñ¨Èô∫È†ºË¶öËàπÈÄîË®±Êäú‰æøÁïôÁΩ™Âä™Á≤æÊï£ÈùôÂ©öÂñúÊµÆÁµ∂Âπ∏ÊäºÂÄíÁ≠âËÄÅÊõ≤ÊâïÂ∫≠ÂæíÂã§ÈÅÖÂ±ÖÈõëÊãõÂõ∞Ê¨†Êõ¥ÂàªË≥õÊä±ÁäØÊÅêÊÅØÈÅ†ÊàªÈ°òÁµµË∂äÊ¨≤ÁóõÁ¨ë‰∫íÊùü‰ººÂàóÊé¢ÈÄÉÈÅäËø∑Â§¢ÂêõÈñâÁ∑íÊäòËçâÊöÆÈÖíÊÇ≤Êô¥ÊéõÂà∞ÂØùÊöóÁõóÂê∏ÈôΩÂæ°Ê≠ØÂøòÈõ™ÂêπÂ®òË™§Ê¥óÊÖ£Á§ºÁ™ìÊòîË≤ßÊÄíÊ≥≥Á•ñÊùØÁñ≤ÁöÜÈ≥¥ËÖπÁÖôÁú†ÊÄñËÄ≥È†ÇÁÆ±Êô©ÂØíÈ´™ÂøôÊâçÈù¥ÊÅ•ÂÅ∂ÂÅâÁå´ÂπæË™∞" )
        , ( 2, "ÂÖöÂçîÁ∑èÂå∫È†òÁúåË®≠‰øùÊîπÁ¨¨ÁµêÊ¥æÂ∫úÊüªÂßîËªçÊ°àÁ≠ñÂõ£ÂêÑÂ≥∂Èù©ÊùëÂã¢Ê∏õÂÜçÁ®éÂñ∂ÊØîÈò≤Ë£úÂ¢ÉÂ∞éÂâØÁÆóËº∏Ëø∞Á∑öËæ≤Â∑ûÊ≠¶Ë±°ÂüüÈ°çÊ¨ßÊãÖÊ∫ñË≥ûËæ∫ÈÄ†Ë¢´ÊäÄ‰ΩéÂæ©ÁßªÂÄãÈñÄË™≤ËÑ≥Ê•µÂê´ËîµÈáèÂûãÊ≥ÅÈáùÂ∞ÇË∞∑Âè≤ÈöéÁÆ°ÂÖµÊé•Á¥∞Âäπ‰∏∏ÊπæÈå≤ÁúÅÊóßÊ©ãÂ≤∏Âë®ÊùêÊà∏Â§ÆÂà∏Á∑®ÊçúÁ´πË∂Ö‰∏¶ÁôÇÊé°Ê£ÆÁ´∂‰ªãÊ†πË≤©Ê≠¥Â∞ÜÂπÖËà¨Ë≤øË¨õÊûóË£ÖË´∏ÂäáÊ≤≥Ëà™ÈâÑÂÖêÁ¶ÅÂç∞ÈÄÜÊèõ‰πÖÁü≠Ê≤πÊö¥Ëº™Âç†Ê§çÊ∏ÖÂÄçÂùáÂÑÑÂúßËä∏ÁΩ≤‰º∏ÂÅúÁàÜÈô∏ÁéâÊ≥¢Â∏ØÂª∂ÁæΩÂõ∫Ââá‰π±ÊôÆÊ∏¨Ë±äÂéöÈΩ¢Âõ≤ÂçíÁï•ÊâøÈ†ÜÂ≤©Á∑¥ËªΩ‰∫ÜÂ∫ÅÂüéÊÇ£Â±§Áâà‰ª§ËßíÁµ°ÊêçÂãüË£è‰ªèÁ∏æÁØâË≤®Ê∑∑ÊòáÊ±†Ë°ÄÊ∏©Â≠£ÊòüÊ∞∏ËëóË™åÂ∫´ÂàäÂÉèÈ¶ôÂùÇÂ∫ïÂ∏ÉÂØ∫ÂÆáÂ∑®ÈúáÂ∏åËß¶‰æùÁ±çÊ±öÊûöË§áÈÉµ‰ª≤Ê†ÑÊú≠ÊùøÈ™®ÂÇæÂ±äÂ∑ªÁáÉË∑°ÂåÖÈßêÂº±Á¥πÈõáÊõøÈ†êÁÑºÁ∞°Á´†ËáìÂæãË¥àÁÖßËñÑÁæ§ÁßíÂ••Ë©∞ÂèåÂà∫Á¥îÁøåÂø´ÁâáÊï¨ÊÇ©Ê≥âÁöÆÊºÅËçíË≤ØÁ°¨ÂüãÊü±Á•≠Ë¢ãÁ≠ÜË®ìÊµ¥Á´•ÂÆùÂ∞ÅËÉ∏Á†ÇÂ°©Ë≥¢ËÖïÂÖÜÂ∫äÊØõÁ∑ëÂ∞äÁ•ùÊüîÊÆøÊøÉÊ∂≤Ë°£ËÇ©Èõ∂ÂπºËç∑Ê≥äÈªÑÁîòËá£ÊµÖÊéÉÈõ≤ÊéòÊç®ËªüÊ≤àÂáç‰π≥ÊÅãÁ¥ÖÈÉäËÖ∞ÁÇ≠Ë∏äÂÜäÂãáÊ¢∞ËèúÁèçÂçµÊπñÂñ´Âπ≤Ëô´Âà∑ÊπØÊ∫∂Èâ±Ê∂ôÂåπÂ≠´Èã≠ÊûùÂ°óËªíÊØíÂè´ÊãùÊ∞∑‰πæÊ£íÁ•àÊãæÁ≤âÁ≥∏Á∂øÊ±óÈäÖÊπøÁì∂Âí≤Âè¨Áº∂ÈöªËÑÇËí∏ËÇåËÄïÈàçÊ≥•ÈöÖÁÅØËæõÁ£®È∫¶ÂßìÁ≠íÈºªÁ≤íË©ûËÉÉÁï≥Êú∫ËÜöÊøØÂ°îÊ≤∏ÁÅ∞ËèìÂ∏ΩÊûØÊ∂ºËàüË≤ùÁ¨¶ÊÜéÁöøËÇØÁá•ÁïúÂùäÊåüÊõáÊª¥‰º∫" )
        ]
